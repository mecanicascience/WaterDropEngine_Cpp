#version 450

layout (local_size_x = 256) in;


// ====== GLOBAL SCENE DATA ======
// Camera set
layout(set = 0, binding = 0) uniform SceneBuffer {
    mat4 view;
    float frustumL; // Data for left frustum planes
    float frustumR; // Data for right frustum planes
    float frustumT; // Data for top frustum planes
    float frustumB; // Data for bottom frustum planes
    float znear;
    float zfar;
    int distCull;
} inSceneData;

// Objects set
struct ObjectData {
    mat4 model;
};
layout(std140, set = 0, binding = 1) readonly buffer ObjectBuffer {
    ObjectData objects[];
} inObjectBuffer;
// ===============================


// ======== OBJECTS DATA =========
// Objects render batches
struct ObjectBatch {
    int objectID;
    int batchID;
    int objectSceneIndex;
};
layout (set = 1, binding = 0) readonly buffer ObjectBatchesBuffer {
    ObjectBatch objects[];
} objectBatches;


// Render Batches
struct RenderBatch {
    int firstIndex;
    int indexCount;
    int instanceCount;
};
layout(set = 1, binding = 1) buffer RenderBatchesBuffer {
    RenderBatch batches[];
} renderBatches;


// Objects ID (will match to gl_instanceID)
layout(set = 1, binding = 2) buffer ObjectsID {
    int ids[];
} objectsIDs;
// ===============================



// ======== PUSH CONSTANTS ========
layout(push_constant) uniform Push {
    int objectsCount;
} inPush;
// ===============================



// Return true if the object is visible on the screen
bool isVisible(uint objectSceneIndex) {
    // Grep object data
    /*vec3 center = vec3(inObjectBuffer.objects[objectSceneIndex].model[3][0], inObjectBuffer.objects[objectSceneIndex].model[3][1], inObjectBuffer.objects[objectSceneIndex].model[3][2]);
    float radius = 0.5;

    // Frustrum culling
    bool visible = true;
    if (inSceneData.distCull <= 0) {
        return false;
    }

    visible = visible && center.z * inSceneData.frustumR - abs(center.x) * inSceneData.frustumL > -radius;
    visible = visible && center.z * inSceneData.frustumB - abs(center.y) * inSceneData.frustumT > -radius;

    if(inSceneData.distCull != 0) { // The near/far plane culling uses camera space Z directly
        visible = visible && center.z + radius > inSceneData.znear && center.z - radius < inSceneData.zfar;
    }
    return visible;*/
    return true;
}


void main() {
    uint gID = gl_GlobalInvocationID.x;
    if(gID < inPush.objectsCount) {
        // Get object batch index
        uint batchIndex = objectBatches.objects[gID].batchID;
        uint objectIndex = objectBatches.objects[gID].objectID;
        uint objectSceneIndex = objectBatches.objects[gID].objectSceneIndex;

        // If visible, add object to the render list
        if (isVisible(objectSceneIndex)) {
            // Add a drawing count to the gameobject batch
            uint countIndex = atomicAdd(renderBatches.batches[batchIndex].instanceCount, 1);

            // Write the object ID into the instance buffer that will map gl_instanceID
            int instanceIndex = renderBatches.batches[batchIndex].firstIndex + int(countIndex);
            objectsIDs.ids[instanceIndex] = int(objectSceneIndex);
        }
    }
}
