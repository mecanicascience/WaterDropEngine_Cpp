#version 450

layout (local_size_x = 256) in;

// Objects render batches
struct ObjectBatch {
    int objectID;
    int batchID;
};
layout (set = 0, binding = 0) readonly buffer ObjectBatchesBuffer {
    ObjectBatch objects[];
} objectBatches;


// Render Batches
struct RenderBatch {
    int firstIndex;
    int indexCount;
    int instanceCount;
};
layout(set = 0, binding = 1) buffer RenderBatchesBuffer {
    RenderBatch batches[];
} renderBatches;


// Objects ID (will match to gl_instanceID)
layout(set = 0, binding = 2) buffer ObjectsID {
    int ids[];
} objectsIDs;


// Push constants
layout(push_constant) uniform Push {
    int objectsCount;
} inPush;


void main() {
    uint gID = gl_GlobalInvocationID.x;
    if(gID < inPush.objectsCount) {
        // Get object batch index
        uint batchIndex = objectBatches.objects[gID].batchID;
        uint objectIndex = objectBatches.objects[gID].objectID;

        // If visible, add object to the render list
        bool visible = true;
        if (objectIndex % 2 == 1) {
            visible = false;
        }
        if (visible) {
            // Add a drawing count to the gameobject batch
            uint countIndex = atomicAdd(renderBatches.batches[batchIndex].instanceCount, 1);

            // Write the object ID into the instance buffer that will map gl_instanceID
            int instanceIndex = renderBatches.batches[batchIndex].firstIndex + int(countIndex);
            objectsIDs.ids[instanceIndex] = int(objectIndex);
        }
    }
}
